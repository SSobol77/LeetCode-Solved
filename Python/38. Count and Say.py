# 38. Count and Say.


# Topic: String.

"""
### Task:
---
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:

   countAndSay(1) = "1"
   countAndSay(n) is the way you would "say" the digit string from countAndSay(n-1), which is then converted into a different digit string.

To determine how you "say" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.

For example, the saying and conversion for digit string "3322251":

Given a positive integer n, return the n^th term of the count-and-say sequence.

Example 1:
Input: n = 1
Output: "1"
Explanation: This is the base case.

Example 2:
Input: n = 4
Output: "1211"
Explanation:
countAndSay(1) = "1"
countAndSay(2) = say "1" = one 1 = "11"
countAndSay(3) = say "11" = two 1's = "21"
countAndSay(4) = say "21" = one 2 + one 1 = "12" + "11" = "1211"

Constraints:
1 <= n <= 30

Hint 1:
Create a helper function that maps an integer to pairs of its digits and their frequencies. For example, if you call this function with "223314444411", then it maps it to an array of pairs [[2,2], [3,2], [1,1], [4,5], [1, 2]].
Hint 2:
Create another helper function that takes the array of pairs and creates a new integer. For example, if you call this function with [[2,2], [3,2], [1,1], [4,5], [1, 2]], it should create "22"+"23"+"11"+"54"+"21" = "2223115421".
Hint 3:
Now, with the two helper functions, you can start with "1" and call the two functions alternatively n-1 times. The answer is the last integer you will obtain.


### Testcase:
---
1
4


### Code:
---
class Solution:
    def countAndSay(self, n: int) -> str:
        
    
"""
### Solution: -------------------------------------------------------------------------------------

class Solution:
    def countAndSay(self, n: int) -> str:
        # Base case: if n is 1, the sequence starts with "1"
        if n == 1:
            return "1"
        
        # Define a function to generate the next term in the sequence
        # based on the current term
        def getNextTerm(term):
            result = []  # Initialize an empty list to store the next term
            count = 1  # Initialize count for the current digit
            # Iterate over the term starting from the second character
            for i in range(1, len(term)):
                # If the current digit is the same as the previous one
                if term[i] == term[i-1]:
                    count += 1  # Increment the count for the current digit
                else:
                    # If the current digit is different, append the count and the previous digit
                    # to the result list
                    result.append(str(count))
                    result.append(term[i-1])
                    count = 1  # Reset count for the new digit
            # After the loop, append the count and the last digit to the result list
            result.append(str(count))
            result.append(term[-1])
            # Convert the result list to a string and return it
            return ''.join(result)
        
        term = "1"  # Start the sequence with the first term "1"
        # Generate the sequence up to the nth term
        for _ in range(n - 1):
            term = getNextTerm(term)  # Generate the next term from the current term
        
        return term  # Return the nth term of the sequence

# Test cases
solution = Solution()
print(solution.countAndSay(1))  # Output: "1"
print(solution.countAndSay(4))  # Output: "1211"



### Description: ==============================================================================================================
'''
The solution to the "Count and Say" problem involves a recursive sequence where each term is generated by verbalizing the count 
of digits in the previous term. The solution is implemented in Python within a class named `Solution`, which contains a method 
`countAndSay` that accepts an integer `n` and returns the `n`th term of the sequence as a string.

The base case for this sequence is when `n` is 1, for which the method simply returns "1". For other values of `n`, the solution 
involves a process of iteratively constructing each term from the previous one until the `n`th term is reached. This is achieved 
through a helper function `getNextTerm`, which is defined within the `countAndSay` method.

The `getNextTerm` function works by iterating over the digits of the current term and counting consecutive occurrences of each digit. 
It constructs the next term by concatenating these counts with their respective digits. This is done by initializing an empty list 
`result`, and as the function iterates over the current term, it appends the count followed by the digit to this list whenever a new 
digit is encountered or at the end of the term. The counts and digits are appended as strings, and finally, the list is joined into a 
single string representing the next term in the sequence.

The `countAndSay` method initializes the sequence with the first term "1" and then iteratively updates this term by calling `getNextTerm`, 
thereby generating each subsequent term up to the `n`th term. The final term obtained after `n-1` iterations is returned as the output.

This approach efficiently generates each term of the sequence without the need for separate data structures to hold intermediate results, 
thus optimizing both time and space complexity. The use of a list to construct the next term and the final conversion to a string using 
the `join` method minimizes memory allocations and string concatenation operations, which are typically costly in terms of performance.

'''
